//未名湖边的烦恼
问题描述
　　每年冬天，北大未名湖上都是滑冰的好地方。北大体育组准备了许多冰鞋，可是人太多了，每天下午收工后，常常一双冰鞋都不剩。
　　每天早上，租鞋窗口都会排起长龙，假设有还鞋的m个，有需要租鞋的n个。现在的问题是，这些人有多少种排法，可以避免出现体育组没有冰鞋可租的尴尬场面。（两个同样需求的人（比如都是租鞋或都是还鞋）交换位置是同一种排法）
输入格式
　　两个整数，表示m和n
输出格式
　　一个整数，表示队伍的排法的方案数。
样例输入
3 2
样例输出
5
数据规模和约定
　　m,n∈［0,18］

f(m, n)表示m人还鞋，n人租鞋的情况下排序种数
首先 如果 m < n 还鞋的如果比租鞋的少，那肯定无解 return 0;
其次 如果 n == 0 鞋没人租 那肯定就一个解 全是还鞋的 return 1;
排除了 m < n 和 n == 0 的情况 递推过程如下：
f(m, n) -> f(m - 1, n) + f(m, n - 1) -> ...- >
f(5, 1) + f(4, 2) + f(3, 3) -> f(4, 1) + f(3, 2) ->
f(3, 1) + f (2, 2) -> f(2, 1) -> f (1, 1)

所以
int f(int m, int n) {
    if (m < n)
        return 0;
    if(n == 0)
        return 1;
    return f(m - 1, n) + f(m, n - 1);
}
#include <iostream>
using namespace std;
int f(int m, int n) {
    if (m < n)
        return 0;
    if(n == 0)
        return 1;
    return f(m - 1, n) + f(m, n - 1);
}

int main() {
    int m, n;
    cin >> m >> n;
    cout << f(m, n);
    return 0;
}
